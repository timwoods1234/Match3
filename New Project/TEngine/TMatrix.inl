#ifndef __TVECTOR3_H__
#include "TVector3.h"
#endif

//-------------------------------------------------------------------------------
__forceinline TMatrix TMatrix::operator*(const TMatrix &other) const
{		
	TMatrix result;
	result.m[0][0] = m[0][0] * other.m[0][0] + m[0][1] * other.m[1][0] + m[0][2] * other.m[2][0] + m[0][3] * other.m[3][0];
	result.m[0][1] = m[0][0] * other.m[0][1] + m[0][1] * other.m[1][1] + m[0][2] * other.m[2][1] + m[0][3] * other.m[3][1];
	result.m[0][2] = m[0][0] * other.m[0][2] + m[0][1] * other.m[1][2] + m[0][2] * other.m[2][2] + m[0][3] * other.m[3][2];
	result.m[0][3] = m[0][0] * other.m[0][3] + m[0][1] * other.m[1][3] + m[0][2] * other.m[2][3] + m[0][3] * other.m[3][3];
	result.m[1][0] = m[1][0] * other.m[0][0] + m[1][1] * other.m[1][0] + m[1][2] * other.m[2][0] + m[1][3] * other.m[3][0];
	result.m[1][1] = m[1][0] * other.m[0][1] + m[1][1] * other.m[1][1] + m[1][2] * other.m[2][1] + m[1][3] * other.m[3][1];
	result.m[1][2] = m[1][0] * other.m[0][2] + m[1][1] * other.m[1][2] + m[1][2] * other.m[2][2] + m[1][3] * other.m[3][2];
	result.m[1][3] = m[1][0] * other.m[0][3] + m[1][1] * other.m[1][3] + m[1][2] * other.m[2][3] + m[1][3] * other.m[3][3];
	result.m[2][0] = m[2][0] * other.m[0][0] + m[2][1] * other.m[1][0] + m[2][2] * other.m[2][0] + m[2][3] * other.m[3][0];
	result.m[2][1] = m[2][0] * other.m[0][1] + m[2][1] * other.m[1][1] + m[2][2] * other.m[2][1] + m[2][3] * other.m[3][1];
	result.m[2][2] = m[2][0] * other.m[0][2] + m[2][1] * other.m[1][2] + m[2][2] * other.m[2][2] + m[2][3] * other.m[3][2];
	result.m[2][3] = m[2][0] * other.m[0][3] + m[2][1] * other.m[1][3] + m[2][2] * other.m[2][3] + m[2][3] * other.m[3][3];
	result.m[3][0] = m[3][0] * other.m[0][0] + m[3][1] * other.m[1][0] + m[3][2] * other.m[2][0] + m[3][3] * other.m[3][0];
	result.m[3][1] = m[3][0] * other.m[0][1] + m[3][1] * other.m[1][1] + m[3][2] * other.m[2][1] + m[3][3] * other.m[3][1];
	result.m[3][2] = m[3][0] * other.m[0][2] + m[3][1] * other.m[1][2] + m[3][2] * other.m[2][2] + m[3][3] * other.m[3][2];
	result.m[3][3] = m[3][0] * other.m[0][3] + m[3][1] * other.m[1][3] + m[3][2] * other.m[2][3] + m[3][3] * other.m[3][3];
	return result;
}

//-------------------------------------------------------------------------------
__forceinline void TMatrix::FastMultiplyNoW(const TMatrix& m1, const TMatrix& m2)
{
	m[0][0] = m1.m[0][0] * m2.m[0][0] + m1.m[0][1] * m2.m[1][0] + m1.m[0][2] * m2.m[2][0] + m1.m[0][3] * m2.m[3][0];
	m[0][1] = m1.m[0][0] * m2.m[0][1] + m1.m[0][1] * m2.m[1][1] + m1.m[0][2] * m2.m[2][1] + m1.m[0][3] * m2.m[3][1];
	m[0][2] = m1.m[0][0] * m2.m[0][2] + m1.m[0][1] * m2.m[1][2] + m1.m[0][2] * m2.m[2][2] + m1.m[0][3] * m2.m[3][2];
	m[1][0] = m1.m[1][0] * m2.m[0][0] + m1.m[1][1] * m2.m[1][0] + m1.m[1][2] * m2.m[2][0] + m1.m[1][3] * m2.m[3][0];
	m[1][1] = m1.m[1][0] * m2.m[0][1] + m1.m[1][1] * m2.m[1][1] + m1.m[1][2] * m2.m[2][1] + m1.m[1][3] * m2.m[3][1];
	m[1][2] = m1.m[1][0] * m2.m[0][2] + m1.m[1][1] * m2.m[1][2] + m1.m[1][2] * m2.m[2][2] + m1.m[1][3] * m2.m[3][2];
	m[2][0] = m1.m[2][0] * m2.m[0][0] + m1.m[2][1] * m2.m[1][0] + m1.m[2][2] * m2.m[2][0] + m1.m[2][3] * m2.m[3][0];
	m[2][1] = m1.m[2][0] * m2.m[0][1] + m1.m[2][1] * m2.m[1][1] + m1.m[2][2] * m2.m[2][1] + m1.m[2][3] * m2.m[3][1];
	m[2][2] = m1.m[2][0] * m2.m[0][2] + m1.m[2][1] * m2.m[1][2] + m1.m[2][2] * m2.m[2][2] + m1.m[2][3] * m2.m[3][2];
	m[3][0] = m1.m[3][0] * m2.m[0][0] + m1.m[3][1] * m2.m[1][0] + m1.m[3][2] * m2.m[2][0] + m1.m[3][3] * m2.m[3][0];
	m[3][1] = m1.m[3][0] * m2.m[0][1] + m1.m[3][1] * m2.m[1][1] + m1.m[3][2] * m2.m[2][1] + m1.m[3][3] * m2.m[3][1];
	m[3][2] = m1.m[3][0] * m2.m[0][2] + m1.m[3][1] * m2.m[1][2] + m1.m[3][2] * m2.m[2][2] + m1.m[3][3] * m2.m[3][2];
}

//-------------------------------------------------------------------------------
inline void TMatrix::RotateVector(const TVector3* pInVector, TVector3* pOutVector) const
{
	*pOutVector = TVector3((pInVector->x * m[0][0]) + (pInVector->y * m[1][0]) + (pInVector->z * m[2][0]),
							(pInVector->x * m[0][1]) + (pInVector->y * m[1][1]) + (pInVector->z * m[2][1]),
							(pInVector->x * m[0][2]) + (pInVector->y * m[1][2]) + (pInVector->z * m[2][2]));
}

//-------------------------------------------------------------------------------
inline void 
TMatrix::RotateVector(TVector3* pVector) const
{
	RotateVector(pVector, pVector);
}

//-------------------------------------------------------------------------------
__forceinline void TMatrix::TransformVector(const TVector3* pInVector, TVector3* pOutVector) const
{
	*pOutVector = TVector3(
			(pInVector->x * m[0][0]) + (pInVector->y * m[1][0]) + (pInVector->z * m[2][0]) + m[3][0],
			(pInVector->x * m[0][1]) + (pInVector->y * m[1][1]) + (pInVector->z * m[2][1]) + m[3][1],
			(pInVector->x * m[0][2]) + (pInVector->y * m[1][2]) + (pInVector->z * m[2][2]) + m[3][2]);
}

//-------------------------------------------------------------------------------
inline void TMatrix::TransformVector(TVector3* pVector) const
{
	TransformVector(pVector, pVector);
}

//-------------------------------------------------------------------------------
__forceinline TMatrix& TMatrix::operator=(const TMatrix &other)
{
	m[0][0] = other.m[0][0];
	m[0][1] = other.m[0][1];
	m[0][2] = other.m[0][2];
	m[0][3] = other.m[0][3];
	m[1][0] = other.m[1][0];
	m[1][1] = other.m[1][1];
	m[1][2] = other.m[1][2];
	m[1][3] = other.m[1][3];
	m[2][0] = other.m[2][0];
	m[2][1] = other.m[2][1];
	m[2][2] = other.m[2][2];
	m[2][3] = other.m[2][3];
	m[3][0] = other.m[3][0];
	m[3][1] = other.m[3][1];
	m[3][2] = other.m[3][2];
	m[3][3] = other.m[3][3];

	return *this;
}
